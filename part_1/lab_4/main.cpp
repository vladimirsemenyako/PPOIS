#include <iostream>
#include "NonOrientedGraph.h"

// In Main.cpp there is example of working this program as a some sort of framework.

int main () {
    // NonOrientedGraph<int> graph;
    //
    // std::cout << "Adding Vertices 1, 2, 3, 4\n";
    // graph.addVertex(1);
    // graph.addVertex(2);
    // graph.addVertex(3);
    // graph.addVertex(4);
    //
    // std::cout << "Adding Edges (1, 2), (2, 3), (3, 4), (4, 1)\n";
    // graph.addEdge(1, 2);
    // graph.addEdge(2, 3);
    // graph.addEdge(3, 4);
    // graph.addEdge(4, 1);
    //
    // std::cout << "Checking for the presence of vertex 2: " << graph.checkVertex(2) << "\n";
    // std::cout << "Checking for the presence of vertex 5: " << graph.checkVertex(5) << "\n";
    // std::cout << "Checking for the presence of edge (1, 2): " << graph.checkEdge(1, 2) << "\n";
    // std::cout << "Checking for the presence of edge (2, 4): " << graph.checkEdge(2, 4) << "\n";
    //
    // std::cout << "Amount of vertices in graph: " << graph.vertexCount() << "\n";
    // std::cout << "Amount of edges in graph: " << graph.edgeCount() << "\n";
    //
    // std::cout << "Vertex degree 2: " << graph.vertexDegree(2) << "\n";
    //
    // std::cout << "\nIteration through vertices:\n";
    // for (auto it = graph.vertexBegin(); it != graph.vertexEnd(); ++it) {
    //     std::cout << *it << " ";
    // }
    // std::cout << "\n";
    //
    // std::cout << "\nIteration through edges:\n";
    // for (auto it = graph.edgeBegin(); it != graph.edgeEnd(); ++it) {
    //     auto edge = *it;
    //     std::cout << "(" << edge.first << ", " << edge.second << ") ";
    // }
    // std::cout << "\n";
    //
    // std::cout << "\nIncident edges for a vertex 2:\n";
    // for (auto it = graph.edgeIncidentBegin(2); it != graph.edgeIncidentEnd(2); ++it) {
    //     auto edge = *it;
    //     std::cout << "(" << edge.first << ", " << edge.second << ") ";
    // }
    // std::cout << "\n";
    //
    // std::cout << "\nAdjacent vertices for a vertex 2:\n";
    // for (auto it = graph.adjacentBegin(2); it != graph.adjacentEnd(2); ++it) {
    //     std::cout << *it << " ";
    // }
    // std::cout << "\n";
    //
    // std::cout << "\nRemoving vertex 3 and edge (1, 2)\n";
    // graph.removeVertex(3);
    // graph.removeEdge(1, 2);
    //
    // std::cout << "Vertices after deleting:\n";
    // for (auto it = graph.vertexBegin(); it != graph.vertexEnd(); ++it) {
    //     std::cout << *it << " ";
    // }
    // std::cout << "\n";
    //
    // std::cout << "Edges after deleting:\n";
    // for (auto it = graph.edgeBegin(); it != graph.edgeEnd(); ++it) {
    //     auto edge = *it;
    //     std::cout << "(" << edge.first << ", " << edge.second << ") ";
    // }
    // std::cout << "\n";

    return 0;
}
